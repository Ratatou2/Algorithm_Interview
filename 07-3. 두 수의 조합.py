#해당 코드는 박상길 저자의 '파이썬 알고리즘 인터뷰'를 공부하며 적은 내용입니다

def twoSum(nums: list, target: int):
    nums_map = {}
    count = 0
    for i, num in enumerate(nums):
        count += 1
        if target - num in nums_map: # 이 코드는 (target - num)한 값을 nums_map에서 키(key)값으로 찾는 것이다. -> 그러면 이제 해당 키의 값을 알 수 있다
            return [nums_map[target-num], i] # []는 결과 값 리스트 형태로 출력하기 위함이다.
        nums_map[num] = i

nums = [1, 3, 6, 9, 13, 17]
target = 15

print(twoSum(nums, target))

''' < 코드 해석 > 
- 일단 앞의 코드와 비슷하지만 살짝 다른 것은 모든 수를 저장하지 않고, 정답이 나올 때까지만 반복한다는 것 
- 따라서 9가 들어간 시점에서 보면 조건과 값들은 다음과 같이 볼 수 있다
(6이 들어가는 타이밍이 아닌 이유는 6은 이미 딕셔너리에 들어가 있어야만, 9의 차례에서 6을 찾을 수 있다
한마디로 for문이 네번째 도는 순간에 정답을 찾게 되는 것_헷갈린 부분)
- 다만 밑에서 결과값의 i가 3인 이유는 i는 0부터 시작되었기 때문에 결과적으론 for문이 4번째 돌았을 때 찾는다는 것이 맞다

for i, num in enumerate(nums):
    if 15 - 9 in {1: 0, 3: 1, 6: 2}: # 이 코드는 (target - num)한 값을 nums_map에서 키(key)값으로 찾는 것이다. -> 그러면 이제 해당 키의 값을 알 수 있다
        return [2, 3] # nums_map[6] -> '키 6'의 '값'을 물어보는 것이니, 당연히 3번째니까 해당 위치의 값인 2 출력
    nums_map[num] = i

- 07-2 코드(for문 3번 반복 후 정답 도출)와 달리 07-3.에선 네번째에서 정답을 찾는 이유는 07-2에선 이미 딕셔너리를 완성한 for문을 먼저 돌려주었기 때문이다
- 즉, 모든 딕셔너리를 알고 있는 상태에서 정답을 찾았기에 15-6일때, 9를 찾아낼 수 있었고,
- 여기서는 for문 한번 돌릴때마다 추가해 넣는 방식이기에 15-9를 하고 나서야 앞서 넣어두었던 6을 찾을 수 있었던 것이다.  

+a : 항상 return이 해당 파트를 끝내고, 그 다음에 실행 될 것이 없다면 그 함수는 거기서 끝나는것이라는 것을 상기할 것
-> 정정 : return은 해당 함수를 '종료'해버리는 것이다. 
즉 위의 코드에선 return이 if문 안에 있으므로 그 뒤엔 뭐가오든 상관없이 if문이 조건 충족 되는 순간 해당 함수는 지정된 값을 반환하고 종료된다
'''